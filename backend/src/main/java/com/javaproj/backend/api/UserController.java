package com.javaproj.backend.api;

import com.javaproj.backend.config.JsonResult;
import com.javaproj.backend.domain.*;
import com.javaproj.backend.model.Favorite;
import com.javaproj.backend.model.History;
import com.javaproj.backend.model.Question;
import com.javaproj.backend.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.DigestUtils;
import org.springframework.web.bind.annotation.*;

import javax.transaction.Transactional;
import java.util.*;

@Transactional
@RestController // This means that this class is a Controller
@RequestMapping(path="/api/user")
public class UserController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;
    @Autowired
    private HistoryRepository historyRepository;
    @Autowired
    private FavoriteRepository favoriteRepository;
    @Autowired
    private QuestionRepository questionRepository;

    @PostMapping(path="/register") // Map ONLY POST Requests
    public JsonResult<User> addNewUser (@RequestParam String name
            , @RequestParam String email, @RequestParam String password) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request
        List<User> userList = userRepository.findAllByName(name);
        if(!userList.isEmpty()) {
            return new JsonResult<>("404", "Name Duplicated!");
        }
        User n = new User();
        n.setName(name);
        n.setEmail(email);
        n.setPassword(password);
        userRepository.save(n);
        return new JsonResult<>(n);
    }

    @GetMapping(path="/login")
    public @ResponseBody JsonResult<User> userLogin(@RequestParam String name, @RequestParam String password) {
        String psw = DigestUtils.md5DigestAsHex(password.getBytes());
        User n1 = userRepository.findByName(name);
        if(n1 == null) {
            return new JsonResult<>("404", "User not found!");
        }
        if(n1.getPassword().equals(psw)) {
            return new JsonResult<>(n1);
        } else {
            return new JsonResult<>("404", "Wrong Password!");
        }
    }

    @PostMapping(path = "/modifyPassword")
    public @ResponseBody
    JsonResult<User> modifyPassword (@RequestParam String name
    , @RequestParam String newPassword, @RequestParam String oldPassword) {
        User n = userRepository.findByName(name);
        if (n == null) {
            return new JsonResult<>("404", "User not found!"); //I guess it never happens.
        }
        String oldPsw = DigestUtils.md5DigestAsHex(oldPassword.getBytes());
        if (!n.getPassword().equals(oldPsw)) {
            return new JsonResult<>("404", "Password wrong!");
        }
        n.setPassword(newPassword);
        userRepository.save(n);
        return new JsonResult<>(n);
    }

    @PostMapping(path = "/modifyInfo")
    public @ResponseBody JsonResult<User> modifyInfo (@RequestParam String name, @RequestParam String newName, @RequestParam String email) {
        User n = userRepository.findByName(name);
        if (n == null) {
            return new JsonResult<>("404", "User not found!"); //I guess it never happens.
        }
        if(!userRepository.findAllByName(newName).isEmpty()) {
            return new JsonResult<>("404", "New Name Duplicated!");
        }
        n.setEmail(email);
        n.setName(newName);
        userRepository.save(n);
        return new JsonResult<>(n);
    }

    @GetMapping(path="/showAllUser")
    public @ResponseBody JsonResult<Iterable<User>> getAllUsers() {
        // This returns a JSON or XML with the users
        return new JsonResult<>(userRepository.findAll());
    }

    @GetMapping(path = "/deleteUser")
    public @ResponseBody JsonResult<Object> deleteUser(@RequestParam String name) {
        userRepository.deleteByName(name);
        return new JsonResult<>();
    }

    /**
     * 任何时候不允许使用！
     * @return JsonResult<User>
     */
    @GetMapping(path="/deleteAllUser")
    public @ResponseBody JsonResult<User> clearUsers() {
        userRepository.deleteAll();
        return new JsonResult<>();
    }

    @GetMapping(path = "/addHistory")
    public @ResponseBody JsonResult<History> addHistory(@RequestParam String instance, @RequestParam String subject, @RequestParam String name) {
        History newHistory = new History();
        newHistory.setUser(userRepository.findByName(name));
        newHistory.setInstance(instance);
        newHistory.setSubject(subject);
        newHistory.setTime(System.currentTimeMillis());
        historyRepository.save(newHistory);
        return new JsonResult<>(newHistory);
    }

    @GetMapping(path = "/showHistory")
    public @ResponseBody JsonResult<List<History>> showHistory(@RequestParam String name) {
        try {
            return new JsonResult<>(historyRepository.findAllByUser(userRepository.findByName(name)));
        } catch (NullPointerException e) {
            return new JsonResult<>("404", "History not exist!");
        }
    }

    @GetMapping(path = "/deleteHistory")
    public @ResponseBody JsonResult<Object> deleteHistory(@RequestParam String instance, @RequestParam String subject, @RequestParam String name) {
        try {
            historyRepository.deleteByInstanceAndSubjectAndUser(instance, subject, userRepository.findByName(name));
            return new JsonResult<>();
        } catch (NullPointerException e) {
            return new JsonResult<>("404", "History not exist!");
        }
    }

    @GetMapping(path = "/deleteAllHistory")
    public @ResponseBody JsonResult<Object> deleteAllHistory(@RequestParam String name) {
        try {
            historyRepository.deleteAllByUser(userRepository.findByName(name));
            return new JsonResult<>();
        } catch (NullPointerException e) {
            return new JsonResult<>("404", "History not exist!");
        }
    }

    @GetMapping(path = "/addFavorite")
    public @ResponseBody JsonResult<Favorite> addFavorite(@RequestParam String instance, @RequestParam String subject, @RequestParam String name) {
        if(favoriteRepository.findByInstanceAndSubjectAndUser(instance, subject, userRepository.findByName(name)) != null) {
            return new JsonResult<>("404", "Favorite already exists!");
        }
        Favorite newFavorite = new Favorite();
        newFavorite.setInstance(instance);
        newFavorite.setSubject(subject);
        newFavorite.setUser(userRepository.findByName(name));
        favoriteRepository.save(newFavorite);
        return new JsonResult<>(newFavorite);
    }

    @GetMapping(path = "/showFavorite")
    public @ResponseBody JsonResult<List<Favorite>> showFavorite(@RequestParam String name) {
        return new JsonResult<>(favoriteRepository.findAllByUser(userRepository.findByName(name)));
    }

    @GetMapping(path = "/deleteFavorite")
    public @ResponseBody JsonResult<Object> deleteFavorite(@RequestParam String instance, @RequestParam String subject, @RequestParam String name) {
        try {
            favoriteRepository.deleteByInstanceAndSubjectAndUser(instance, subject, userRepository.findByName(name));
            return new JsonResult<>();
        } catch (NullPointerException e) {
            return new JsonResult<>("404", "Favorite not exist!");
        }
    }

    @GetMapping(path = "/deleteAllFavorite")
    public @ResponseBody JsonResult<Object> deleteAllFavorite(@RequestParam String name) {
        try {
            favoriteRepository.deleteAllByUser(userRepository.findByName(name));
            return new JsonResult<>();
        } catch (NullPointerException e) {
            return new JsonResult<>("404", "Favorite not exist!");
        }
    }

    @GetMapping(path = "/addQuestion")
    public @ResponseBody JsonResult<Object> addQuestion(@RequestParam Long questionID, @RequestParam String qBody, @RequestParam String qAnswer, @RequestParam String name) {
        if(questionRepository.findByQuestionIDAndUser(questionID, userRepository.findByName(name)) != null) {
            return new JsonResult<>("404", "Question already exists!");
        }
        Question question = new Question();
        question.setQuestionID(questionID);
        question.setAddTime(System.currentTimeMillis());
        question.setqBody(qBody);
        question.setqAnswer(qAnswer);
        question.setRedoTimes(0);
        question.setRedoCorrectTimes(0);
        question.setUser(userRepository.findByName(name));
        questionRepository.save(question);
        return new JsonResult<>(question);
    }

    @GetMapping(path = "/showQuestion")
    public @ResponseBody JsonResult<Object> showQuestion(@RequestParam String name) {
        return new JsonResult<>(questionRepository.findAllByUser(userRepository.findByName(name)));
    }

    @GetMapping(path = "/deleteQuestion")
    public @ResponseBody JsonResult<Object> deleteQuestion(@RequestParam Long questionID, @RequestParam String name) {
        try {
            questionRepository.deleteByQuestionIDAndUser(questionID, userRepository.findByName(name));
            return new JsonResult<>();
        } catch (Exception e) {
            return new JsonResult<>("404", "Error!");
        }
    }

    @GetMapping(path = "/addRightTimes")
    public @ResponseBody JsonResult<Object> addRightTimes(@RequestParam Long questionID, @RequestParam String name) {
        Question question = questionRepository.findByQuestionIDAndUser(questionID, userRepository.findByName(name));
        question.setRedoCorrectTimes(question.getRedoCorrectTimes() + 1);
        question.setRedoTimes(question.getRedoTimes() + 1);
        return new JsonResult<>(question);
    }

    @GetMapping(path = "/addWrongTimes")
    public @ResponseBody JsonResult<Object> addWrongTimes(@RequestParam Long questionID, @RequestParam String name) {
        Question question = questionRepository.findByQuestionIDAndUser(questionID, userRepository.findByName(name));
        question.setRedoTimes(question.getRedoTimes() + 1);
        return new JsonResult<>(question);
    }


}